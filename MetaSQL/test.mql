-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
/**
 * This query is a MetaSQL test query intended to cover all MetaSQL
 * functionality. For this test to pass, specific parameters must be sent to
 * the MetaSQL parser. The MetaSQL parser will need the following parameters
 * for the test to pass:
 *
 * var params = {
 *                start: true
 *                ,test_0_1_0: 'test_0_1_0'
 *                ,test_0_1_2: ['test_0_1_2']
 *                ,test_0_1_3: ['test_0_1_3', 'test_0_1_3_2', 'test_0_1_3_3']
 *                ,test_0_1_4: 'true THEN true END AS test_0_1_4) AS tests; SELECT current_user--'
 *                ,test_0_2_0: 'test_0_2_0'
 *                ,test_0_2_2: ['test_0_2_2']
 *                ,test_0_2_3: ['test_0_2_3','test_0_2_3_2', 'test_0_2_3_3']
 *                ,test_0_2_4: '(SELECT usr_username FROM usr WHERE usr_username = 'admin')'
 *                ,test_0_3_0: true
 *                ,test_0_3_2: null
 *                ,test_0_3_3: ''
 *                ,test_0_3_4: 'true THEN true END AS test_0_3_4) AS test; SELECT current_user--'
 *                ,test_0_4_0a: 'test_0_4_0'
 *                ,test_0_4_2a: null
 *                ,test_0_4_3a: ''
 *                ,test_0_4_4a: 'true THEN true END AS test_0_4_4) AS test; SELECT current_user--'
 *                ,test_0_5_0: ['test_0_5_0']
 *                ,test_0_5_1: ['test_0_5_1','test_0_5_1_2', 'test_0_5_1_3']
 *                ,test_0_5_2: 'test_0_5_2'
 *                ,test_0_5_4: ['true THEN true END AS test_0_5_4) AS test; SELECT current_user--']
 *                ,test_0_6_0: ['test_0_6_0']
 *                ,test_0_6_1: ['test_0_6_1','test_0_6_1_2', 'test_0_6_1_3']
 *                ,test_0_6_2: 'test_0_6_2'
 *                ,test_0_6_4: ['true THEN true END AS test_0_6_4) AS test; SELECT current_user--']
 *                ,bar: ['T','O','D','O']
 *                ,baz: 1234
 *                ,end: true
 *              }
 *
 * The query tests are named following this convention from the MetaSQL docs:
 * @See: http://www.xtuple.org/node/270
 *
 * Control Statements (#.x.x):
 * - none             (0.x.x)
 * - if               (1.x.x)
 * - else             (2.x.x)
 * - elseif           (3.x.x)
 * - foreach          (4.x.x)
 *
 * Functions          (x.#.x):
 * - value            (x.1.x)
 * - literal          (x.2.x)
 * - exists           (x.3.x)
 * - reExists         (x.4.x)
 * - isFirst          (x.5.x)
 * - isLast           (x.6.x)
 * - continue         (x.7.x)
 * - break            (x.8.x)
 *
 * Function Logic     (x.x.#):
 * - Addresses expected logic function within the above functions calls such as
 *   what the expected outcome is when certain conditions exists or parameters
 *   are passed.
 *
 * All tests have a column that corresponds to the test name. e.g. Test "0.1.3"
 * has a column named "valid_0_1_3". Each column's value should be true if the
 * tests pass. Any column with a value of false means that test failed.
 */
SELECT
  thestart
  ,test_0_1_0 AS valid_0_1_0
  ,test_0_1_1 AS valid_0_1_1
  ,test_0_1_2 AS valid_0_1_2
  ,test_0_1_3 AS valid_0_1_3
  ,test_0_1_4 AS valid_0_1_4
  ,CASE WHEN test_0_2_0 = 'test_0_2_0' THEN true ELSE false END AS valid_0_2_0
  ,CASE WHEN test_0_2_1 = '''test_0_2_1''' THEN true ELSE false END AS valid_0_2_1
  ,CASE WHEN test_0_2_2 = 'test_0_2_2' THEN true ELSE false END AS valid_0_2_2
  ,CASE WHEN test_0_2_3 = 'test_0_2_3' THEN true ELSE false END AS valid_0_2_3
  -- TODO: This currently fails in the Qt MetaSQL parser and is something we should fix in the javascript parser.
  ,CASE WHEN test_0_2_4 = 'test_0_2_4' THEN true ELSE false END AS "TODO_0_2_4"
  ,test_0_3_0 AS valid_0_3_0
  ,CASE WHEN test_0_3_1 THEN false ELSE true END AS valid_0_3_1
  ,test_0_3_2 AS valid_0_3_2
  ,test_0_3_3 AS valid_0_3_3
  ,test_0_3_4 AS valid_0_3_4
  ,test_0_4_0 AS valid_0_4_0
  ,CASE WHEN test_0_4_1 = '''test_0_4_1''' THEN true ELSE false END AS valid_0_4_1
  ,test_0_4_2 AS valid_0_4_2
  ,test_0_4_3 AS valid_0_4_3
  ,test_0_4_4 AS valid_0_4_4
  ,test_0_5_0 AS valid_0_5_0
  ,test_0_5_1 AS valid_0_5_1
  ,test_0_5_2 AS valid_0_5_2
  ,test_0_5_3 AS valid_0_5_3
  ,test_0_5_4 AS valid_0_5_4
  ,test_0_6_0 AS valid_0_6_0
  ,CASE WHEN test_0_6_1 THEN false ELSE true END AS valid_0_6_1
  ,CASE WHEN test_0_6_2 THEN false ELSE true END AS test_0_6_2
  ,CASE WHEN test_0_6_3 THEN false ELSE true END AS valid_0_6_3
  ,test_0_6_4 AS valid_0_6_4
  ,CASE WHEN test_0_7_0 = '''test_0_7_0''' THEN true ELSE false END AS valid_0_7_0
  ,CASE WHEN test_0_7_1 = '''test_0_7_1''' THEN true ELSE false END AS valid_0_7_1
  ,CASE WHEN test_0_8_0 = '''test_0_8_0''' THEN true ELSE false END AS valid_0_8_0
  ,CASE WHEN test_0_8_1 = '''test_0_8_1''' THEN true ELSE false END AS valid_0_8_1
  ,theend
FROM (
  SELECT
    -- Placeholder so all columns below can start with a comma.
    true AS thestart

    -- Test 0.1.0 - value with a parameter.
    -- Expected: parameter value
    ,CASE WHEN <? value("test_0_1_0") ?> = 'test_0_1_0' THEN true ELSE false END AS test_0_1_0

    -- Test 0.1.1 - value with a parameter that does not exist.
    -- Expected: NULL
    ,CASE WHEN <? value("not_exist") ?> IS NULL THEN true ELSE false END AS test_0_1_1

    -- Test 0.1.2 - value with a list of one item.
    -- Expected: first list item value
    ,CASE WHEN <? value("test_0_1_2") ?> = 'test_0_1_2' THEN true ELSE false END AS test_0_1_2

    -- Test 0.1.3 - value with a list of more than one item.
    -- Expected: first list item value
    ,CASE WHEN <? value("test_0_1_3") ?> = 'test_0_1_3' THEN true ELSE false END AS test_0_1_3

    -- Test 0.1.4 - value SQL injection is quoted.
    -- Expected: quoted value
    ,CASE WHEN <? value("test_0_1_4") ?> = 'true THEN true END AS test_0_1_4) AS test; SELECT current_user--' THEN true ELSE false END AS test_0_1_4

    -- Test 0.2.0 - literal with a parameter.
    -- Expected: parameter literal
    ,'test_0_2_0'::text AS <? literal("test_0_2_0") ?>

    -- Test 0.2.1 - literal with a parameter that does not exist.
    -- Expected: literal returns nothing and will not break this
    ,quote_literal('test_0_2_1'::text || ''<? literal("not_exist") ?>) AS test_0_2_1

    -- Test 0.2.2 - literal with a list of one item.
    -- Expected: first list item literal
    ,'test_0_2_2'::text AS <? literal("test_0_2_2") ?>

    -- Test 0.2.3 - literal with a list of more than one item.
    -- Expected: first list item literal
    ,'test_0_2_3'::text AS <? literal("test_0_2_3") ?>

    -- Test 0.2.4 - literal SQL injection.
    -- Expected: fails
    -- TODO: This currently fails in the Qt MetaSQL parser and is something we should fix in the javascript parser.
    ,quote_literal('test_0_2_4'::text || <? literal("test_0_2_4") ?>) AS test_0_2_4

    -- Test 0.3.0 - exists with a parameter does exist.
    -- Expected: TRUE
    ,<? exists("test_0_3_0") ?> AS test_0_3_0

    -- Test 0.3.1 - exists with a parameter does not exist.
    -- Expected: FALSE
    ,<? exists("not_exist") ?> AS test_0_3_1

    -- Test 0.3.2 - exists with a parameter does exist, but is NULL.
    -- Expected: TRUE
    ,<? exists("test_0_3_2") ?> AS test_0_3_2

    -- Test 0.3.3 - exists with a parameter does exist, but is ''.
    -- Expected: TRUE
    ,<? exists("test_0_3_3") ?> AS test_0_3_3

    -- Test 0.3.4 - exists SQL injection.
    -- Expected: TRUE - SQLi fails
    ,CASE WHEN <? exists("test_0_3_4") ?> THEN true ELSE false END AS test_0_3_4

    -- Test 0.4.0 - reExists with a pattern for a parameter does exist.
    -- Expected: TRUE
    ,<? reExists("^test_0_4_0.*") ?> AS test_0_4_0

    -- Test 0.4.1 - reExists with a pattern for a parameter does not exist.
    -- Expected: reExists returns nothing and will not break this
    ,quote_literal('test_0_4_1'::text || ''<? reExists("^not_exist.*") ?>) AS test_0_4_1

    -- Test 0.4.2 - reExists with a pattern for a parameter does exist, but is
    -- NULL.
    -- Expected: TRUE
    ,<? reExists("^test_0_4_2.*") ?> AS test_0_4_2

    -- Test 0.4.3 - reExists with a pattern for a parameter does exist, but is ''.
    -- Expected: TRUE
    ,<? reExists("^test_0_4_3.*") ?> AS test_0_4_3

    -- Test 0.4.4 - reExists SQL injection.
    -- Expected: TRUE - SQLi fails
    ,CASE WHEN <? reExists("^test_0_4_4.*") ?> THEN true ELSE false END AS test_0_4_4

    -- Test 0.5.0 - isFirst with a list of one item.
    -- Expected: TRUE
    ,<? isFirst("test_0_5_0") ?> AS test_0_5_0

    -- Test 0.5.1 - isFirst with a list of more than one item.
    -- Expected: TRUE
    ,<? isFirst("test_0_5_1") ?> AS test_0_5_1

    -- Test 0.5.2 - isFirst not a list, but parameter does exist.
    -- Expected: TRUE
    ,<? isFirst("test_0_5_2") ?> AS test_0_5_2

    -- Test 0.5.3 - isFirst with a parameter that does not exist.
    -- Expected: TRUE - because this is outside a foreach loop
    ,<? isFirst("not_exist") ?> AS test_0_5_3

    -- Test 0.5.4 - isFirst list of one item SQL injection.
    -- Expected: TRUE - SQLi fails
    ,CASE WHEN <? isFirst("test_0_5_4") ?> THEN true ELSE false END AS test_0_5_4

    -- Test 0.6.0 - isLast with a list of one item.
    -- Expected: TRUE
    ,<? isLast("test_0_6_0") ?> AS test_0_6_0

    -- Test 0.6.1 - isLast with a list of more than one item.
    -- Expected: FALSE
    ,<? isLast("test_0_6_1") ?> AS test_0_6_1

    -- Test 0.6.2 - isLast not a list, but parameter does exist.
    -- Expected: FALSE
    ,<? isLast("test_0_6_2") ?> AS test_0_6_2

    -- Test 0.6.3 - isLast with a parameter that does not exist.
    -- Expected: FALSE
    ,<? isLast("not_exist") ?> AS test_0_6_3

    -- Test 0.6.4 - isLast list of one item SQL injection.
    -- Expected: TRUE - SQLi fails
    ,CASE WHEN <? isLast("test_0_6_4") ?> THEN true ELSE false END AS test_0_6_4

    -- Test 0.7.0 - continue.
    -- Expected: continue does nothing and will not break this
    ,quote_literal('test_0_7_0'::text || ''<? continue ?>) AS test_0_7_0

    -- Test 0.7.1 - continue when a number is specified.
    -- Expected: continue does nothing and will not break this
    ,quote_literal('test_0_7_1'::text || ''<? continue(2) ?>) AS test_0_7_1

    -- Test 0.8.0 - break.
    -- Expected: break does nothing and will not break this
    ,quote_literal('test_0_8_0'::text || ''<? break ?>) AS test_0_8_0

    -- Test 0.8.1 - break when a number is specified.
    -- Expected: break does nothing and will not break this
    ,quote_literal('test_0_8_1'::text || ''<? break(2) ?>) AS test_0_8_1

-- Test 1.1.0 - basic if.
-- Expected: if works

-- Test 1.1.1 - basic if SQL injection.
-- Expected: fails

-- Test 2.1.0 - if and else.
-- Expected: if and else works

-- Test 3.1.0 - if, elseif and else.
-- Expected: if, elseif and else works

-- Test 3.1.1 - basic elseif SQL injection.
-- Expected: fails

-- Test 4.0.0 - basic foreach.
-- Expected: loops

-- Test 4.0.1 - basic foreach SQL injection.
-- Expected: fails

-- Test 41.0.0 - foreach with basic if.
-- Expected: loops and if works

-- Test 42.0.0 - foreach with if and else.
-- Expected: loops and if and else works

-- Test 43.0.0 - foreach with if, elseif and else.
-- Expected: loops and if, elseif and else works

-- Test 4.1.0 - value called inside a foreach block looping on this parameter
-- with a parameter.
-- Expected: parameter value

-- Test 4.1.1 - value called inside a foreach block looping on this parameter
-- with a parameter that does not exist.
-- Expected: NULL

-- Test 4.1.2 - value called inside a foreach block looping on this parameter
-- with a list of one item.
-- Expected: first list item value
-- TODO: Then what for remaining loops?

-- Test 4.1.3 - value called inside a foreach block looping on this parameter
-- with a list of more than one item.
-- Expected: loop indexed list item value

-- Test 4.1.4 - value called inside a foreach block not looping on this
-- parameter with a parameter.
-- Expected: parameter value

-- Test 4.1.5 - value called inside a foreach block not looping on this
-- parameter with a list of one item.
-- Expected: first list item value
-- TODO: Then what for remaining loops?

-- Test 4.1.6 - value called inside a foreach block not looping on this
-- parameter with a list of more than one item.
-- Expected: loop indexed list item value

-- Test 4.1.7 - value SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.2.0 - literal called inside a foreach block looping on this parameter
-- with a parameter.
-- Expected: parameter literal

-- Test 4.2.1 - literal called inside a foreach block looping on this parameter
-- with a parameter that does not exist.
-- Expected: NULL

-- Test 4.2.2 - literal called inside a foreach block looping on this parameter
-- with a list of one item.
-- Expected: first list item literal
-- TODO: Then what for remaining loops?

-- Test 4.2.3 - literal called inside a foreach block looping on this parameter
-- with a list of more than one item.
-- Expected: loop indexed list item literal

-- Test 4.2.4 - literal called inside a foreach block not looping on this
-- parameter with a parameter.
-- Expected: parameter literal

-- Test 4.2.5 - literal called inside a foreach block not looping on this
-- parameter with a list of one item.
-- Expected: first list item literal
-- TODO: Then what for remaining loops?

-- Test 4.2.6 - literal called inside a foreach block not looping on this
-- parameter with a list of more than one item.
-- Expected: loop indexed list item literal

-- Test 4.2.7 - literal SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.3.0 - exists called inside a foreach block with a parameter does
-- exist.
-- Expected: TRUE

-- Test 4.3.1 - exists called inside a foreach block with a parameter does
-- not exist.
-- Expected: FALSE

-- Test 4.3.2 - exists called inside a foreach block with a parameter does
-- exist, but is NULL.
-- Expected: TRUE

-- Test 4.3.3 - exists called inside a foreach block with a parameter does
-- exist, but is ''.
-- Expected: TRUE

-- Test 4.3.4 - exists SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.4.0 - reExists called inside a foreach block with a pattern for a
-- parameter does exist.
-- Expected: TRUE

-- Test 4.4.1 - reExists called inside a foreach block with a pattern for a
-- parameter does not exist.
-- Expected: FALSE

-- Test 4.4.2 - reExists called inside a foreach block with a pattern for a
-- parameter does exist, but is NULL.
-- Expected: TRUE

-- Test 4.4.3 - reExists called inside a foreach block with a pattern for a
-- parameter does exist, but is ''.
-- Expected: TRUE

-- Test 4.4.4 - reExists SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.5.0 - isFirst called inside a foreach block with a list of one item.
-- Expected: TRUE

-- Test 4.5.1 - isFirst called inside a foreach block with a list first item.
-- Expected: TRUE

-- Test 4.5.2 - isFirst called inside a foreach block not a list first item.
-- Expected: FALSE

-- Test 4.5.3 - isFirst called inside a foreach block not a list, but parameter
-- does exist.
-- Expected: TRUE

-- Test 4.5.4 - isFirst called inside a foreach block with a parameter that
-- does not exist.
-- Expected: FALSE

-- Test 4.5.5 - isFirst SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.6.0 - isLast called inside a foreach block with a list of one item.
-- Expected: TRUE

-- Test 4.6.1 - isLast called inside a foreach block with a list last item.
-- Expected: TRUE

-- Test 4.6.2 - isLast called inside a foreach block not a list last item.
-- Expected: FALSE

-- Test 4.6.3 - isLast called inside a foreach block not a list, but parameter
-- does exist.
-- Expected: TRUE

-- Test 4.6.4 - isLast called inside a foreach block with a parameter that does
-- not exist.
-- Expected: FALSE

-- Test 4.6.5 - isLast SQL injection inside a foreach block.
-- Expected: fails

-- Test 4.7.0 - continue inside a foreach block.
-- Expected: loop execution continues

-- Test 4.7.1 - continue inside a foreach block SQL injection.
-- Expected: fails

-- Test 4.8.0 - break inside a foreach block.
-- Expected: loop execution breaks

-- Test 4.8.1 - break inside a foreach block SQL injection.
-- Expected: fails

-- Test 44.0.0 - foreach with nested foreach.
-- Expected: Both loops loop

-- Test 441.0.0 - foreach with nested foreach with basic if.
-- Expected: Both loops loop and if works

-- Test 442.0.0 - foreach with nested foreach with if and else.
-- Expected: Both loops loop and if and else works

-- Test 443.0.0 - foreach with nested foreach with if, elseif and else.
-- Expected: Both loops loop and if, elseif and else works

-- Test 44.7.0 - continue inside a nested foreach block.
-- Expected: loop execution continues

-- Test 44.7.1 - continue inside a nested foreach block SQL injection.
-- Expected: fails

-- Test 44.8.0 - break inside a nested foreach block.
-- Expected: inside loop execution breaks

-- Test 44.8.1 - break inside a nested foreach block SQL injection.
-- Expected: fails

-- Test 444.0.0 - Test foreach with double nested foreach.
-- Expected: All loops loop

-- Test 444.7.0 - continue inside a double nested foreach block when a number
-- is specified.
-- Expected: loop execution continues for nested loop number

-- Test 444.7.1 - continue inside a double nested foreach block when a number
-- is specified greater than the number of nested loops.
-- Expected: continues to the outermost loop execution

-- Test 444.8.0 - break inside a double nested foreach block when a number is
-- specified.
-- Expected: loop execution breaks to the nested loop number

-- Test 444.8.1 - break inside a double nested foreach block when a number is
-- specified greater than the number of nested loops.
-- Expected: breaks all loop execution

    -- Placeholder to test if we made it to the end of all test.
    ,true AS theend
) AS tests;
